from manim import *
import numpy as np
from manim.opengl import *
class Projectile_Motion1(Scene):
    def construct(self):
        theta=ValueTracker(45)
        plane=NumberPlane().shift(LEFT*5)
        curve=always_redraw(lambda:DashedVMobject(plane.plot(lambda x:x*np.tan(np.deg2rad(theta.get_value()))
                -(x**2)*(np.cos(np.deg2rad(theta.get_value())))**(-2)/20,
                x_range=(0,10*np.sin(2*np.deg2rad(theta.get_value())))),num_dashes=40))
        ball=Circle(radius=0.25,color=BLUE,fill_opacity=1).shift(LEFT*5)
        horizontal=DashedLine(start=ball.get_center(),end=ball.get_center()+RIGHT*1.3)
        velocity_vector=always_redraw(lambda:Line(start=ball.get_center(),
                    end=ball.get_center()+2*RIGHT*np.cos(np.deg2rad(theta.get_value()))+2*UP*np.sin(np.deg2rad(theta.get_value())),color=RED).add_tip().set_stroke(width=6))
        angle_arc=always_redraw(lambda:Arc(radius=0.6,arc_center=ball.get_center(),angle=np.deg2rad(theta.get_value()),color=YELLOW))
        start_point=ball.get_center()
        velocity_tex=always_redraw(lambda: MathTex(r"\vec{v}",color=RED).next_to(ball,UP,buff=0.06).rotate(angle=np.deg2rad(theta.get_value()+0.06*UP),about_point=ball.get_center()).shift(RIGHT*np.cos(np.deg2rad(theta.get_value()))+UP*np.sin(np.deg2rad(theta.get_value()))))
        self.play(DrawBorderThenFill(ball))
        self.play(AnimationGroup(*[Create(x) for x in [horizontal,angle_arc]],lag_ratio=1))
        self.play(Create(curve))
        self.play(GrowFromPoint(velocity_vector,point=ball.get_center()))
        self.play(Write(velocity_tex))
        self.wait(0.5)
        self.play(theta.animate.set_value(80))
        self.play(theta.animate.set_value(45))
        self.play(theta.animate.set_value(0.1))
        self.play(theta.animate.set_value(50))
        velocity_vector.clear_updaters()
        angle_arc.clear_updaters()
        velocity_tex.clear_updaters()
        curve.clear_updaters()
        theta_new_tex=MathTex(r"\theta=",f"{theta.get_value():.1f}",r"^\circ",color=YELLOW).set_color_by_tex(r"\theta=",WHITE).move_to(ball.get_center()+1.7*RIGHT+0.5*UP)
        self.play(Write(theta_new_tex))
        self.play(theta_new_tex.animate.to_edge(UL))
        theta_new_tex.add_background_rectangle(buff=0.2,color=BLACK,opacity=1)
        rect_1=RoundedRectangle(corner_radius=0.2,color=GREEN,height=theta_new_tex.height,width=theta_new_tex.width).move_to(theta_new_tex.get_center())
        self.play(Create(rect_1))
        x=ValueTracker(0)
        theta_0=theta.get_value()
        theta.add_updater(lambda theta:theta.set_value(np.rad2deg(np.arctan(np.tan(np.deg2rad(theta_0))-0.1*x.get_value()*(np.cos(np.deg2rad(theta_0)))**(-2)))))
        theta_new_tex.add_updater(lambda a:a.become(MathTex(r"\theta=",f"{np.abs(theta.get_value()):.1f}",r"^\circ",color=YELLOW).set_color_by_tex(r"\theta=",WHITE).to_edge(UL)).add_background_rectangle(buff=0.2,color=BLACK,opacity=1))
        ball.add_updater(lambda ball:ball.move_to((x.get_value()-5,x.get_value()*np.tan(np.deg2rad(theta_0))-(x.get_value()**2)*(np.cos(np.deg2rad(theta_0)))**(-2)/20,0)))
        horizontal.add_updater(lambda x:x.become(DashedLine(start=ball.get_center(),end=ball.get_center()+RIGHT*1.3)))
        velocity_vector.add_updater(lambda a:a.become(Line(start=ball.get_center(),
                    end=ball.get_center()+2*RIGHT*np.cos(np.deg2rad(theta.get_value()))+2*UP*np.sin(np.deg2rad(theta.get_value())),color=RED).add_tip().set_stroke(width=6)))
        angle_arc.add_updater(lambda a:a.become(Arc(radius=0.6,arc_center=ball.get_center(),angle=np.deg2rad(theta.get_value()),color=YELLOW)))
        velocity_tex.add_updater(lambda d:d.become(MathTex(r"\vec{v}",color=RED).next_to(ball,UP,buff=0.06).rotate(angle=np.deg2rad(theta.get_value()+0.06*UP),about_point=ball.get_center()).shift(RIGHT*np.cos(np.deg2rad(theta.get_value()))+UP*np.sin(np.deg2rad(theta.get_value())))))
        self.play(x.animate.set_value(10*np.sin(2*np.deg2rad(theta_0))),run_time=3,rate_func=linear)
        self.play(Wait(0.2))
        
        end_point=ball.get_center()
        br_x=BraceBetweenPoints(point_1=start_point,point_2=end_point,color=PURPLE)
        max_x=(10*np.sin(2*np.deg2rad(theta_0)))
        x_range=MathTex(r"R").next_to(br_x,DOWN)
        self.play(AnimationGroup(FadeIn(br_x),Write(x_range),lag_ratio=1))
        vertical_max=start_point+(0.5*max_x*np.tan(np.deg2rad(theta_0))-(0.5*max_x)**2/(20*(np.cos(np.deg2rad(theta_0)))**2))*UP
        br_y=BraceBetweenPoints(point_1=start_point,point_2=vertical_max+0.1*DOWN,direction=LEFT,color=PURPLE)
        y_range=MathTex(r"h").next_to(br_y,LEFT)
        self.play(FadeIn(br_y))
        self.play(Write(y_range))
        self.play(x.animate.set_value(0),run_time=3,rate_func=linear)
        self.wait(0.2)
        v_0_label=MathTex(r"v_0=",r"10.0\mathrm{\,m\,s}^{-1}",color=YELLOW).set_color_by_tex(r"v_0=",WHITE).add_background_rectangle(buff=0.2,color=BLACK,opacity=1).next_to(x_range,DOWN)
        rect_v_0_label=RoundedRectangle(corner_radius=0.2,color=PURPLE,height=v_0_label.height,width=v_0_label.width).move_to(v_0_label.get_center())
        rect_v_0_label.add_updater(lambda m: m.move_to(v_0_label.get_center()))
        self.play(Write(v_0_label))
        self.play(Create(rect_v_0_label))
        rect_1.add_updater(lambda m: m.move_to(theta_new_tex.get_center()))
        theta_new_tex.clear_updaters()
        self.wait(1)
        bg_stuff=VGroup(br_x,br_y,x_range,y_range,curve)
        for mob in bg_stuff:
            mob.clear_updaters()
        self.play(FadeOut(bg_stuff))
        self.play(v_0_label.animate.next_to(theta_new_tex,RIGHT))
        theta_on_diagram=MathTex(r"\theta",color=YELLOW).move_to(ball.get_center()+RIGHT*1.2+UP*0.6)
        vertical_component_of_v_0=Line(start=ball.get_center(),end=ball.get_center()+2*UP*np.sin(np.deg2rad(theta_0)),color=GREEN).add_tip().set_stroke(width=6)
        horizontal_component_of_v_0=Line(start=ball.get_center(),end=ball.get_center()+2*RIGHT*np.cos(np.deg2rad(theta_0)),color=YELLOW).add_tip().set_stroke(width=6)
        vertical_tex=MathTex(r"v_0\sin{\theta}",color=GREEN).next_to(vertical_component_of_v_0,LEFT)
        horizontal_tex=MathTex(r"v_0\cos{\theta}",color=YELLOW).next_to(horizontal_component_of_v_0,DOWN)
        self.play(GrowFromPoint(vertical_component_of_v_0,point=ball.get_center()),GrowFromPoint(horizontal_component_of_v_0,point=ball.get_center()))
        self.play(Write(theta_on_diagram))
        l0=MathTex(r"v=u+a\times t").next_to(v_0_label,DR)
        l1=MathTex(r"v_y=",r"v_0\sin{\theta}",r"-gt").next_to(l0,DOWN)
        l1[1].set_color(GREEN)
        self.play(Write(vertical_tex),Write(horizontal_tex))
        t=np.sin(np.deg2rad(theta_0))*10/9.81
        l2=MathTex(r"0=v_0\sin{\theta}-gt").next_to(l1,DOWN)
        l3=MathTex(r"v_0 \sin{\theta}=gt").next_to(l2,DOWN)
        l4=MathTex(r"9.81\times t=10\times \sin",f"{theta_0:.1f}",r"^\circ").next_to(l3,DOWN)
        l5=MathTex(r"t=\frac{10}{9.81} \times \sin",f"{theta_0:.1f}",r"^\circ}").next_to(l4,DOWN)
        l6=MathTex(r"\therefore t \approx",f"{t:.3g}",r"\, \mathrm{s}",color=YELLOW).set_color_by_tex(r"t \approx",WHITE).next_to(l5,DOWN)
        self.play(Write(l0))
        l1_1=l1[1].copy()
        self.play(TransformMatchingShapes(vertical_tex,l1_1))
        self.play(Write(l1))
        self.wait(0.5)
        self.play(TransformMatchingShapes(l1.copy(),l2))
        self.wait(0.5)
        self.play(TransformMatchingShapes(l2.copy(),l3))
        self.wait(0.5)
        self.play(TransformMatchingShapes(l3.copy(),l4))
        self.wait(0.5)
        self.play(TransformMatchingShapes(l4.copy(),l5))
        self.wait(0.5)
        self.play(TransformMatchingShapes(l5.copy(),l6))
        l6.add_background_rectangle(buff=0.2,color=BLACK,opacity=1)
        l6_border=always_redraw(lambda: RoundedRectangle(corner_radius=0.2,color=BLUE,height=l6.height,width=l6.width).move_to(l6.get_center()))
        self.play(Create(l6_border))
        self.wait(1)
        lines_without_6=VGroup(l2,l3,l4,l5)
        self.play(FadeOut(lines_without_6),FadeOut(l0),FadeOut(l1),FadeOut(l1_1))
        self.wait(0.2)
        self.play(l6.animate.become(MathTex(r"t \approx",f"{t:.3g}",r"\,\mathrm{s}",color=YELLOW).set_color_by_tex(r"t \approx",WHITE).next_to(l5,DOWN).add_background_rectangle(buff=0.2,color=BLACK,opacity=1)))
        self.play(l6.animate.next_to(v_0_label,RIGHT))
        R=10*np.cos(np.deg2rad(theta_0))*2*t
        h=10*np.sin(np.deg2rad(theta_0))*t-0.5*9.81*t**2
        m1=MathTex(r"v_0\cos \theta",r"\times T=R").next_to(v_0_label,DR)
        m1[0].set_color(YELLOW)
        m1_1=m1[0].copy()
        m2=MathTex(r"v_0\cos \theta",r"\times 2t=R").next_to(m1,DOWN)
        m3=MathTex(r"R=10 \times \cos",f"{theta_0:.1f}",r"^\circ \times 2 \times",f"{t:.3g}").next_to(m2,DOWN)
        m4=MathTex(r"\therefore R \approx",f"{R:.3g}",r"\;m",color=YELLOW).next_to(m3,DOWN)
        m4[0].set_color(WHITE)
        n1=MathTex(r"h=ut+\frac{1}{2}at^2").next_to(v_0_label,DR)
        n2=MathTex(r"h=v_0\sin \theta \times t-\frac{1}{2}\times g\times t^2")
        n3=MathTex(r"h=10\times \sin",f"{theta_0:.1f}", r"^\circ\times",f"{t:.3g}",r"-\frac{1}{2}\times 9.81\times",f"{t:.3g}",r"^2")
        n4=MathTex(r"\therefore h \approx",f"{h:.3g}",r"\,m",color=YELLOW)
        n4[0].set_color(WHITE)
        self.play(TransformMatchingShapes(horizontal_tex,m1_1))
        self.wait(0.5)
        self.play(Write(m1))
        self.wait(0.5)
        self.play(TransformMatchingShapes(m1.copy(),m2))
        self.wait(0.5)
        self.play(TransformMatchingShapes(m2.copy(),m3))
        self.wait(0.5)
        self.play(TransformMatchingShapes(m3.copy(),m4))
        m4.add_background_rectangle(buff=0.2,color=BLACK,opacity=1)
        m4_border=always_redraw(lambda: RoundedRectangle(corner_radius=0.2,color=RED,height=m4.height,width=m4.width).move_to(m4.get_center()))
        self.play(Create(m4_border))
        self.wait(1)
        self.play(*[FadeOut(mob) for mob in [m1,m2,m3,m1_1]])
        self.wait(0.2)
        self.play(m4.animate.next_to(l6,RIGHT))
        n_group=VGroup(n1,n2,n3,n4).arrange(DOWN)
        self.play(Write(n1))
        self.wait(0.5)
        self.play(TransformMatchingShapes(n1.copy(),n2))
        self.wait(0.5)
        self.play(TransformMatchingShapes(n2.copy(),n3))
        self.wait(0.5)
        self.play(TransformMatchingShapes(n3.copy(),n4))
        n4.add_background_rectangle(buff=0.2,color=BLACK,opacity=1)
        n4_border=always_redraw(lambda: RoundedRectangle(corner_radius=0.2,color=YELLOW,height=n4.height,width=n4.width).move_to(n4.get_center()))
        self.play(Create(n4_border))
        self.wait(1)
        self.play(*[FadeOut(mob) for mob in [n1,n2,n3]])
        self.wait(0.2)
        self.play(n4.animate.next_to(m4,DOWN))
        self.wait(1)
        ball_stuff=VGroup(ball,horizontal,velocity_vector,velocity_tex,angle_arc,horizontal_component_of_v_0,vertical_component_of_v_0,theta_on_diagram)
        for mob in ball_stuff:
            mob.clear_updaters()
        bg_stuff.shift(DOWN*2)
        T=MathTex(r"T \approx",f"{2*t:.3g}",r"\,\mathrm{s}",color=YELLOW).set_color_by_tex(r"T \approx",WHITE).next_to(l6,DOWN,0.35).add_background_rectangle(buff=0.2,color=BLACK,opacity=1)
        T_border=always_redraw(lambda: RoundedRectangle(corner_radius=0.2,color=TEAL,height=T.height,width=T.width).move_to(T.get_center()))
        self.play(Write(T),Write(T_border))
        self.play(ball_stuff.animate.shift(DOWN*2))
        self.play(FadeIn(bg_stuff))
        